// Generated by CoffeeScript 1.3.3
(function() {

  describe("TOML", function() {
    it("should handle an empty string", function() {
      return expect(TOML.parse("")).toEqual({});
    });
    it("should handle a simple key value assignment", function() {
      return expect(TOML.parse('title = "TOML Example"')).toEqual({
        title: "TOML Example"
      });
    });
    it("should handle two lines with key value assignments", function() {
      return expect(TOML.parse('a = "A"\nb = "B"')).toEqual({
        a: 'A',
        b: 'B'
      });
    });
    it("should handle quoted strings", function() {
      return expect(TOML.parse('a = "a \\"quoted\\" string"')).toEqual({
        a: 'a "quoted" string'
      });
    });
    it("should handle escaped newlines", function() {
      return expect(TOML.parse('bio = "GitHub Cofounder & CEO\\nLikes tater tots and beer."')).toEqual({
        bio: "GitHub Cofounder & CEO\nLikes tater tots and beer."
      });
    });
    it("should handle a key group", function() {
      return expect(TOML.parse('[group]\na = "A"\nb = "B"')).toEqual({
        group: {
          a: "A",
          b: "B"
        }
      });
    });
    it("should handle conscutive key groups", function() {
      return expect(TOML.parse('[group]\na = "A"\nb = "B"\n[another]\nc = "C"\nd = "D"')).toEqual({
        group: {
          a: "A",
          b: "B"
        },
        another: {
          c: "C",
          d: "D"
        }
      });
    });
    it("should handle nested key groups", function() {
      var result;
      result = TOML.parse('[first]\na = "A"\nb = "B"\n  [second]\n  c = "C"\n  d = "D"');
      return expect(result).toEqual({
        first: {
          a: "A",
          b: "B",
          second: {
            c: "C",
            d: "D"
          }
        }
      });
    });
    it("should handle keygroups with . separators", function() {
      return expect(TOML.parse('[a.b]\nc = "C"\n[a.d]\ne = "E"')).toEqual({
        a: {
          b: {
            c: "C"
          },
          d: {
            e: "E"
          }
        }
      });
    });
    it("should handle integers", function() {
      return expect(TOML.parse('a = 1')).toEqual({
        a: 1
      });
    });
    it("should handle negative integers", function() {
      return expect(TOML.parse('a = -1')).toEqual({
        a: -1
      });
    });
    it("should handle floats", function() {
      return expect(TOML.parse('a = 1.2')).toEqual({
        a: 1.2
      });
    });
    it("should handle negative floats", function() {
      return expect(TOML.parse('a = -1.2')).toEqual({
        a: -1.2
      });
    });
    it("should handle booleans", function() {
      return expect(TOML.parse('a = true\nb = false')).toEqual({
        a: true,
        b: false
      });
    });
    it("should handle dates", function() {
      var result;
      result = TOML.parse('date = 1979-05-27T07:32:00Z');
      return expect(result.date.getFullYear()).toEqual(1979);
    });
    it("should handle arrays", function() {
      return expect(TOML.parse('a = [1,2,3]')).toEqual({
        a: [1, 2, 3]
      });
    });
    it("should handle nested arrays", function() {
      return expect(TOML.parse('a = [[1,2],[3,4]]')).toEqual({
        a: [[1, 2], [3, 4]]
      });
    });
    it("should handle nested arrays with strings and integers", function() {
      return expect(TOML.parse('data = [ ["gamma", "delta"], [1, 2] ] # just an update to make sure parsers support it')).toEqual({
        data: [["gamma", "delta"], [1, 2]]
      });
    });
    return it("should handle comments", function() {
      var result;
      result = TOML.parse('# A comment\n\na = 1 # one\n[b] # comment\nc = [ # test\n1, # array\n2 # comments\n]');
      return expect(result).toEqual({
        a: 1,
        b: {
          c: [1, 2]
        }
      });
    });
  });

}).call(this);
